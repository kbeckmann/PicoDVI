;
; Copyright (c) 2022 Konrad Beckmann
;
; SPDX-License-Identifier: BSD-3-Clause
;

.program n64

; Video
; Data is stable on Negedge of CLK
; 0-6 = data
; 7   = dsync
; 8   = clk

; Audio
;  9 = SDAT
; 10 = LRCLK
; 11 = BCLK

n64_video_start:

    ; Change IO dir of all pins to INPUT
    ; mov osr, null
    ; out pindirs, 32

wait_for_dsyncn:

    ; Wait for high CLK
    wait 1 pin 8

    ; Wait for low CLK
    wait 0 pin 8

    ; if DSYNC: goto wait_for_dsyncn
    jmp pin wait_for_dsyncn

    ; DSYNC = 0

    ; Sample into SYNC
    in pins, 8 ; SYNC
    ; Wait for high CLK
    wait 1 pin 8

    ; Wait for low CLK
    wait 0 pin 8 
    in pins, 8 ; R
    ; Wait for high CLK
    wait 1 pin 8

    ; Wait for low CLK
    wait 0 pin 8 
    in pins, 8 ; G
    ; Wait for high CLK
    wait 1 pin 8

    ; Wait for low CLK
    wait 0 pin 8 
    in pins, 8 ; B

    push

    jmp n64_video_start


public n64_audio_start:

    ; First phase - let's do single channel PIO first

    ; Wait for rising edge of LRCLK (known initial state)
    ; While true {
    ;   Skip the first bit (Left channel)
    ;   Read 16 bits on BCLK rising edge into shiftreg
    ;     If LRCLK == 0, break
    ;   Skip the first bit (Right channel)
    ;   Read 16 bits on BCLK rising edge into shiftreg
    ;     If LRCLK == 1, break
    ; }

    ; Wait for posedge LRCLK
    wait 0 pin 1
    wait 1 pin 1

n64_audio_left_start:

.wrap_target

    ; ------
    ; Skip the first sample (17th stray bit of previous sample)
    ; Wait for low BCLK
    wait 0 pin 2

    ; Time between this step and the next is a few microseconds.
    ; Use time to set variables etc.

    ; Set x=15 (Sample 16 bits)
    set x, 15

    ; Double check that LRCLK == 1. Should help recover desync issues.

    ; Wait for high BCLK
    wait 1 pin 2

    ; End of skip
    ; ------

n64_audio_left_capture_loop:
    ; Wait for low BCLK
    wait 0 pin 2

    ; Wait for high BCLK
    wait 1 pin 2

    ; Sample a data bit
    in pins, 1

    jmp x-- n64_audio_left_capture_loop

; ----------------------------------------------------------
; Left channel has been captured. Capture right channel now.
; ----------------------------------------------------------

n64_audio_right_start:

    ; ------
    ; Skip the first sample (17th stray bit of previous sample)
    ; Wait for low BCLK
    wait 0 pin 2

    ; Time between this step and the next is a few microseconds.
    ; Use time to set variables etc.

    ; Set x=15 (Sample 16 bits)
    set x, 15

    ; Double check that LRCLK == 0. Should help recover desync issues.

    ; Wait for high BCLK
    wait 1 pin 2

    ; End of skip
    ; ------


n64_audio_right_capture_loop:
    ; Wait for low BCLK
    wait 0 pin 2

    ; Wait for high BCLK
    wait 1 pin 2

    ; Sample a data bit
    in pins, 1

    jmp x-- n64_audio_right_capture_loop

; ----------------------------------------------------------
; Right channel has been captured.
; ----------------------------------------------------------

    ; Push the 32 bits of data
    push

    ; Loop (Implicit loop because of wrap/wrap_target)
    ; jmp n64_audio_left_start    

.wrap


% c-sdk {
void n64_video_program_init(PIO pio, uint sm, uint offset)
{
    // gpio0 -> 8 input
    for (int i = 0; i <= 8; i++) {
        pio_gpio_init(pio, i);
    }

    pio_sm_config c = n64_program_get_default_config(offset);

    // Double the FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    sm_config_set_out_shift(&c, true, false, 32);

    // GPIO0 -> GPIO8 as in pins
    sm_config_set_in_pins(&c, 0);

    // JMP pin = DSYNCn
    sm_config_set_jmp_pin(&c, 7);

    pio_sm_init(pio, sm, offset, &c);
}

void n64_audio_program_init(PIO pio, uint sm, uint offset)
{
    // gpio9 -> 11 input
    for (int i = 9; i <= 11; i++) {
        pio_gpio_init(pio, i);
    }

    pio_sm_config c = n64_program_get_default_config(offset);

    // Double the FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // MSB first, shift left
    sm_config_set_in_shift(&c, false, false, 32);

    // GPIO9 as in pin start
    sm_config_set_in_pins(&c, 9);

    pio_sm_init(pio, sm, offset + n64_offset_n64_audio_start, &c);
}
%}
